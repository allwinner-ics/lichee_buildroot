diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/drv_display_sun4i.h DirectFB-1.4.11/gfxdrivers/vmware/drv_display_sun4i.h
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/drv_display_sun4i.h	1970-01-01 08:00:00.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/drv_display_sun4i.h	2011-06-08 11:46:12.733390000 +0800
@@ -0,0 +1,654 @@
+#ifndef __DRV_DISPLAY_H__
+#define __DRV_DISPLAY_H__
+
+#include <linux/types.h>
+#define __bool signed char
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#ifndef __BSP_DRV_DISPLAY_H__
+#define __BSP_DRV_DISPLAY_H__
+
+typedef struct {__u8  alpha;__u8 red;__u8 green; __u8 blue; }__disp_color_t;
+typedef struct {__s32 x; __s32 y; __u32 width; __u32 height;}__disp_rect_t;
+typedef struct {__u32 width;__u32 height;                   }__disp_rectsz_t;
+typedef struct {__s32 x; __s32 y;                           }__disp_pos_t;
+
+
+typedef enum
+{
+    DISP_FORMAT_1BPP        =0x0,
+    DISP_FORMAT_2BPP        =0x1,
+    DISP_FORMAT_4BPP        =0x2,
+    DISP_FORMAT_8BPP        =0x3,
+    DISP_FORMAT_RGB655      =0x4,
+    DISP_FORMAT_RGB565      =0x5,
+    DISP_FORMAT_RGB556      =0x6,
+    DISP_FORMAT_ARGB1555    =0x7,
+    DISP_FORMAT_RGBA5551    =0x8,
+    DISP_FORMAT_RGB888      =0x9,
+    DISP_FORMAT_ARGB8888    =0xa,
+
+    DISP_FORMAT_YUV444      =0xb,
+    DISP_FORMAT_YUV422      =0xc,
+    DISP_FORMAT_YUV420      =0xd,
+    DISP_FORMAT_YUV411      =0xe,
+    DISP_FORMAT_CSIRGB      =0xf,
+}__disp_pixel_fmt_t;
+
+
+typedef enum
+{
+    DISP_MOD_INTERLEAVED        =0x1,   //interleaved,1个地址
+    DISP_MOD_NON_MB_PLANAR      =0x0,   //无宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_NON_MB_UV_COMBINED =0x2,   //无宏块UV打包模式,2个地址,Y和UV分别存放
+    DISP_MOD_MB_PLANAR          =0x4,   //宏块平面模式,3个地址,RGB/YUV每个channel分别存放
+    DISP_MOD_MB_UV_COMBINED     =0x6,   //宏块UV打包模式 ,2个地址,Y和UV分别存放
+}__disp_pixel_mod_t;
+
+typedef enum
+{
+//for interleave argb8888
+    DISP_SEQ_ARGB   =0x0,//A在高位
+    DISP_SEQ_BGRA   =0x2,
+    
+//for nterleaved yuv422
+    DISP_SEQ_UYVY   =0x3,  
+    DISP_SEQ_YUYV   =0x4,
+    DISP_SEQ_VYUY   =0x5,
+    DISP_SEQ_YVYU   =0x6,
+    
+//for interleaved yuv444
+    DISP_SEQ_AYUV   =0x7,  
+    DISP_SEQ_VUYA   =0x8,
+    
+//for uv_combined yuv420
+    DISP_SEQ_UVUV   =0x9,  
+    DISP_SEQ_VUVU   =0xa,
+    
+//for 16bpp rgb
+    DISP_SEQ_P10    = 0xd,//p1在高位
+    DISP_SEQ_P01    = 0xe,//p0在高位
+    
+//for planar format or 8bpp rgb
+    DISP_SEQ_P3210  = 0xf,//p3在高位
+    DISP_SEQ_P0123  = 0x10,//p0在高位
+    
+//for 4bpp rgb
+    DISP_SEQ_P76543210  = 0x11,
+    DISP_SEQ_P67452301  = 0x12,
+    DISP_SEQ_P10325476  = 0x13,
+    DISP_SEQ_P01234567  = 0x14,
+    
+//for 2bpp rgb
+    DISP_SEQ_2BPP_BIG_BIG       = 0x15,//15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_2BPP_BIG_LITTER    = 0x16,//12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3
+    DISP_SEQ_2BPP_LITTER_BIG    = 0x17,//3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12
+    DISP_SEQ_2BPP_LITTER_LITTER = 0x18,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+    
+//for 1bpp rgb
+    DISP_SEQ_1BPP_BIG_BIG       = 0x19,//31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
+    DISP_SEQ_1BPP_BIG_LITTER    = 0x1a,//24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7
+    DISP_SEQ_1BPP_LITTER_BIG    = 0x1b,//7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24
+    DISP_SEQ_1BPP_LITTER_LITTER = 0x1c,//0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+}__disp_pixel_seq_t;
+
+typedef enum
+{
+    DISP_3D_SRC_MODE_TB = 0x0,//top bottom
+    DISP_3D_SRC_MODE_FP = 0x1,//frame packing
+    DISP_3D_SRC_MODE_SSF = 0x2,//side by side full
+    DISP_3D_SRC_MODE_SSH = 0x3,//side by side half
+    DISP_3D_SRC_MODE_LI = 0x4,//line interleaved
+}__disp_3d_src_mode_t;
+
+typedef enum
+{
+    //for lcd
+    DISP_3D_OUT_MODE_CI_1 = 0x5,//column interlaved 1
+    DISP_3D_OUT_MODE_CI_2 = 0x6,//column interlaved 2
+    DISP_3D_OUT_MODE_CI_3 = 0x7,//column interlaved 3
+    DISP_3D_OUT_MODE_CI_4 = 0x8,//column interlaved 4
+    DISP_3D_OUT_MODE_LIRGB = 0x9,//line interleaved rgb
+
+    //for hdmi
+    DISP_3D_OUT_MODE_TB = 0x0,//top bottom
+    DISP_3D_OUT_MODE_FP = 0x1,//frame packing
+    DISP_3D_OUT_MODE_SSF = 0x2,//side by side full
+    DISP_3D_OUT_MODE_SSH = 0x3,//side by side half
+    DISP_3D_OUT_MODE_LI = 0x4,//line interleaved
+    DISP_3D_OUT_MODE_FA = 0xa,//field alternative
+}__disp_3d_out_mode_t;
+
+typedef enum
+{
+    DISP_BT601  = 0,
+    DISP_BT709  = 1,
+    DISP_YCC    = 2,
+    DISP_VXYCC  = 3,
+}__disp_cs_mode_t;
+
+typedef enum
+{
+    DISP_OUTPUT_TYPE_NONE   = 0,
+    DISP_OUTPUT_TYPE_LCD    = 1,
+    DISP_OUTPUT_TYPE_TV     = 2,
+    DISP_OUTPUT_TYPE_HDMI   = 4,
+    DISP_OUTPUT_TYPE_VGA    = 8,
+}__disp_output_type_t;
+
+typedef enum
+{
+    DISP_TV_NONE    = 0,
+    DISP_TV_CVBS    = 1,
+    DISP_TV_YPBPR   = 2,
+    DISP_TV_SVIDEO  = 4,
+}__disp_tv_output_t;
+
+typedef enum
+{
+    DISP_TV_MOD_480I                = 0,
+    DISP_TV_MOD_576I                = 1,
+    DISP_TV_MOD_480P                = 2,
+    DISP_TV_MOD_576P                = 3,
+    DISP_TV_MOD_720P_50HZ           = 4,
+    DISP_TV_MOD_720P_60HZ           = 5,
+    DISP_TV_MOD_1080I_50HZ          = 6,
+    DISP_TV_MOD_1080I_60HZ          = 7,
+    DISP_TV_MOD_1080P_24HZ          = 8,
+    DISP_TV_MOD_1080P_50HZ          = 9,
+    DISP_TV_MOD_1080P_60HZ          = 0xa,
+    DISP_TV_MOD_PAL                 = 0xb,
+    DISP_TV_MOD_PAL_SVIDEO          = 0xc,
+    DISP_TV_MOD_PAL_CVBS_SVIDEO     = 0xd,
+    DISP_TV_MOD_NTSC                = 0xe,
+    DISP_TV_MOD_NTSC_SVIDEO         = 0xf,
+    DISP_TV_MOD_NTSC_CVBS_SVIDEO    = 0x10,
+    DISP_TV_MOD_PAL_M               = 0x11,
+    DISP_TV_MOD_PAL_M_SVIDEO        = 0x12,
+    DISP_TV_MOD_PAL_M_CVBS_SVIDEO   = 0x13,
+    DISP_TV_MOD_PAL_NC              = 0x14,
+    DISP_TV_MOD_PAL_NC_SVIDEO       = 0x15,
+    DISP_TV_MOD_PAL_NC_CVBS_SVIDEO  = 0x16,
+}__disp_tv_mode_t;
+
+typedef enum
+{
+    DISP_TV_DAC_SRC_COMPOSITE = 0,
+    DISP_TV_DAC_SRC_LUMA = 1,
+    DISP_TV_DAC_SRC_CHROMA = 2,
+    DISP_TV_DAC_SRC_Y = 4,
+    DISP_TV_DAC_SRC_PB = 5,
+    DISP_TV_DAC_SRC_PR = 6,
+    DISP_TV_DAC_SRC_NONE = 7,
+}__disp_tv_dac_source;
+
+typedef enum
+{
+    DISP_VGA_H1680_V1050    = 0,
+    DISP_VGA_H1440_V900     = 1,
+    DISP_VGA_H1360_V768     = 2,
+    DISP_VGA_H1280_V1024    = 3,
+    DISP_VGA_H1024_V768     = 4,
+    DISP_VGA_H800_V600      = 5,
+    DISP_VGA_H640_V480      = 6,
+    DISP_VGA_H1440_V900_RB  = 7,//not support yet
+    DISP_VGA_H1680_V1050_RB = 8,//not support yet
+    DISP_VGA_H1920_V1080_RB = 9,
+    DISP_VGA_H1920_V1080    = 0xa,
+    DISP_VGA_H1280_V720     = 0xb,
+}__disp_vga_mode_t;
+
+
+typedef enum
+{
+    DISP_LCDC_SRC_DE_CH1    = 0,
+    DISP_LCDC_SRC_DE_CH2    = 1,
+    DISP_LCDC_SRC_DMA       = 2,
+    DISP_LCDC_SRC_WHITE     = 3,
+    DISP_LCDC_SRC_BLACK     = 4,
+    DISP_LCDC_SRC_BLUT      = 5,
+}__disp_lcdc_src_t;
+
+typedef enum
+{
+    DISP_LCD_BRIGHT_LEVEL0  = 0,
+    DISP_LCD_BRIGHT_LEVEL1  = 1,
+    DISP_LCD_BRIGHT_LEVEL2  = 2,
+    DISP_LCD_BRIGHT_LEVEL3  = 3,
+    DISP_LCD_BRIGHT_LEVEL4  = 4,
+    DISP_LCD_BRIGHT_LEVEL5  = 5,
+    DISP_LCD_BRIGHT_LEVEL6  = 6,
+    DISP_LCD_BRIGHT_LEVEL7  = 7,
+    DISP_LCD_BRIGHT_LEVEL8  = 8,
+    DISP_LCD_BRIGHT_LEVEL9  = 9,
+    DISP_LCD_BRIGHT_LEVEL10 = 0xa,
+    DISP_LCD_BRIGHT_LEVEL11 = 0xb,
+    DISP_LCD_BRIGHT_LEVEL12 = 0xc,
+    DISP_LCD_BRIGHT_LEVEL13 = 0xd,
+    DISP_LCD_BRIGHT_LEVEL14 = 0xe,
+    DISP_LCD_BRIGHT_LEVEL15 = 0xf,
+}__disp_lcd_bright_t;
+
+typedef enum
+{
+    DISP_LAYER_WORK_MODE_NORMAL     = 0,    //normal work mode
+    DISP_LAYER_WORK_MODE_PALETTE    = 1,    //palette work mode 
+    DISP_LAYER_WORK_MODE_INTER_BUF  = 2,    //internal frame buffer work mode
+    DISP_LAYER_WORK_MODE_GAMMA      = 3,    //gamma correction work mode
+    DISP_LAYER_WORK_MODE_SCALER     = 4,    //scaler work mode
+}__disp_layer_work_mode_t;
+
+typedef enum
+{
+    DISP_VIDEO_NATUAL       = 0,
+    DISP_VIDEO_SOFT         = 1,
+    DISP_VIDEO_VERYSOFT     = 2,
+    DISP_VIDEO_SHARP        = 3,
+    DISP_VIDEO_VERYSHARP    = 4
+}__disp_video_smooth_t;
+
+typedef enum
+{
+    DISP_HWC_MOD_H32_V32_8BPP = 0,
+    DISP_HWC_MOD_H64_V64_2BPP = 1,
+    DISP_HWC_MOD_H64_V32_4BPP = 2,
+    DISP_HWC_MOD_H32_V64_4BPP = 3,
+}__disp_hwc_mode_t;
+
+typedef enum
+{
+    DISP_EXIT_MODE_CLEAN_ALL    = 0,
+    DISP_EXIT_MODE_CLEAN_PARTLY = 1,//only clean interrupt temply
+}__disp_exit_mode_t;
+
+typedef struct
+{
+    __u32               addr[3];    // frame buffer的内容地址，对于rgb类型，只有addr[0]有效
+    __disp_rectsz_t     size;//单位是pixel
+    __disp_pixel_fmt_t  format;
+    __disp_pixel_seq_t  seq;
+    __disp_pixel_mod_t  mode;
+    __bool              br_swap;    // blue red color swap flag, FALSE:RGB; TRUE:BGR,only used in rgb format
+    __disp_cs_mode_t    cs_mode;    //color space 
+    __bool              b_interlace;
+    __bool              b_trd_src;
+    __disp_3d_src_mode_t    trd_mode;
+    __u32               trd_right_addr[3];//used when in frame packing 3d mode
+}__disp_fb_t;
+
+typedef struct
+{
+    __disp_layer_work_mode_t    mode;       //layer work mode
+    __bool                      b_from_screen;
+    __u8                        pipe;       //layer pipe,0/1,if in scaler mode, scaler0 must be pipe0, scaler1 must be pipe1
+    __u8                        prio;       //layer priority,can get layer prio,but never set layer prio,从顶至顶,优先级由低至高
+    __bool                      alpha_en;   //layer global alpha enable
+    __u16                       alpha_val;  //layer global alpha value 
+    __bool                      ck_enable;  //layer color key enable
+    __disp_rect_t               src_win;    // framebuffer source window,only care x,y if is not scaler mode
+    __disp_rect_t               scn_win;    // screen window
+    __disp_fb_t                 fb;         //framebuffer
+}__disp_layer_info_t;
+
+typedef struct
+{
+    __disp_color_t   ck_max;
+    __disp_color_t   ck_min;
+    __u32             red_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min 
+    __u32             green_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min 
+    __u32             blue_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min 
+}__disp_colorkey_t;
+
+typedef struct
+{
+    __s32   id;
+    __u32   addr[3];
+    __u32   addr_right[3];//used when in frame packing 3d mode
+    __bool  interlace;
+    __bool  top_field_first;
+    __u32   frame_rate; // *FRAME_RATE_BASE(现在定为1000)
+    __u32   flag_addr;//dit maf flag address
+    __u32   flag_stride;//dit maf flag line stride
+    __bool  maf_valid;
+    __bool  pre_frame_valid;
+}__disp_video_fb_t;
+
+typedef struct
+{
+    __bool maf_enable;
+    __bool pre_frame_enable;
+}__disp_dit_info_t;
+
+typedef struct
+{
+    __disp_hwc_mode_t     pat_mode;
+    __u32                 addr;
+}__disp_hwc_pattern_t;
+
+typedef struct
+{
+    __disp_fb_t     input_fb;
+    __disp_rect_t   source_regn;
+    __disp_fb_t     output_fb;
+    //__disp_rect_t   out_regn;
+}__disp_scaler_para_t;
+
+
+typedef struct
+{
+    __disp_fb_t       fb;
+    __disp_rect_t   src_win;//source region,only care x,y because of not scaler
+    __disp_rect_t   scn_win;// sceen region 
+}__disp_sprite_block_para_t;
+
+typedef struct
+{
+    __disp_rectsz_t screen_size;//used when the screen is not displaying on any output device(lcd/hdmi/vga/tv)
+    __disp_fb_t     output_fb;
+}__disp_capture_screen_para_t;
+
+typedef struct
+{
+    __s32 (*Hdmi_open)(void);
+    __s32 (*Hdmi_close)(void);
+    __s32 (*hdmi_set_mode)(__disp_tv_mode_t mode);
+    __s32 (*hdmi_mode_support)(__u8 mode);
+    __s32 (*hdmi_get_HPD_status)(void);
+}__disp_hdmi_func;
+
+typedef struct
+{
+	__u32   port_index;
+
+	__u8    lcd_if; //0:hv(sync+de); 1:8080; 2:ttl; 3:lvds
+	__u8    lcd_swap;
+	__u16   lcd_x;
+	__u16   lcd_y;
+	__u16   lcd_dclk_freq;
+
+	__u8    lcd_uf;
+	__u16   lcd_vt;
+	__u16   lcd_ht;
+	__u16   lcd_vbp;
+	__u16   lcd_hbp;
+
+	__u8    lcd_hv_if;
+	__u8    lcd_hv_smode;
+	__u8    lcd_hv_s888_if;
+	__u8    lcd_hv_syuv_if;
+	__u8    lcd_hv_vspw;
+	__u16   lcd_hv_hspw;
+
+	__u8    lcd_hv_lde_used;
+	__u8    lcd_hv_lde_iovalue;
+
+	__u32   lcd_ttl_stvh;
+	__u32   lcd_ttl_stvdl;
+	__u32   lcd_ttl_stvdp;
+
+	__u32   lcd_ttl_ckvt;
+	__u32   lcd_ttl_ckvh;
+	__u32   lcd_ttl_ckvd;
+
+	__u32   lcd_ttl_oevt;
+	__u32   lcd_ttl_oevh;
+	__u32   lcd_ttl_oevd;
+
+	__u32   lcd_ttl_sthh;
+	__u32   lcd_ttl_sthd;
+	__u32   lcd_ttl_oehh;
+	__u32   lcd_ttl_oehd;
+
+	__u32   lcd_ttl_revd;
+
+	__u32   lcd_ttl_datarate;
+	__u32   lcd_ttl_revsel;
+	__u32   lcd_ttl_datainv_en;
+	__u32   lcd_ttl_datainv_sel;
+	__u8    lcd_cpu_if;//0:18bit; 1:16bit mode0; 2:16bit mode1; 3:16bit mode2; 4:16bit mode3; 5:9bit; 6:8bit 256K; 7:8bit 65K
+	__u8    lcd_cpu_da;
+	__u32   lcd_frm;
+
+	__u32   lcd_io_cfg0;
+	__u32   lcd_io_cfg1;
+
+	__u32   lcd_srgb;
+	__u32   lcd_io_strength;
+
+	__u32   lcd_pwm_freq;
+	__u32   lcd_pwm_pol;
+
+	__u32   start_delay;//not need to config for user
+	__u32   tcon_index; //not need to config for user
+}__panel_para_t;
+
+typedef struct
+{
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_pioc;
+	__u32 base_ccmu;
+	__u32 base_pwm;
+}__reg_bases_t;
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct
+{
+	__disp_layer_work_mode_t mode;
+	__u32 width;
+	__u32 height;
+	__u32 line_length;//in byte unit
+	__u32 smem_len;
+	__u32 ch1_offset;
+	__u32 ch2_offset;
+	__u32 b_double_buffer;
+	__u32 b_dual_screen;
+}__disp_fb_create_para_t;
+
+
+typedef enum tag_DISP_CMD
+{
+//----disp global----
+    DISP_CMD_RESERVE0 = 0x00,
+    DISP_CMD_RESERVE1 = 0x01,
+    DISP_CMD_SET_BKCOLOR = 0x3f,//fail when the value is 0x02 in linux,why???
+    DISP_CMD_GET_BKCOLOR = 0x03,
+    DISP_CMD_SET_COLORKEY = 0x04,
+    DISP_CMD_GET_COLORKEY = 0x05,
+    DISP_CMD_SET_PALETTE_TBL = 0x06,
+    DISP_CMD_GET_PALETTE_TBL = 0x07,
+    DISP_CMD_SCN_GET_WIDTH = 0x08,
+    DISP_CMD_SCN_GET_HEIGHT = 0x09,
+    DISP_CMD_GET_OUTPUT_TYPE = 0x0a,
+    DISP_CMD_SET_EXIT_MODE = 0x0c,
+    DISP_CMD_SET_GAMMA_TABLE = 0x0d,
+    DISP_CMD_GAMMA_CORRECTION_ON = 0x0e,
+    DISP_CMD_GAMMA_CORRECTION_OFF = 0x0f,
+    DISP_CMD_START_CMD_CACHE =0x10,
+    DISP_CMD_EXECUTE_CMD_AND_STOP_CACHE = 0x11,
+    DISP_CMD_SET_BRIGHT = 0x12,
+    DISP_CMD_SET_CONTRAST = 0x13,
+    DISP_CMD_SET_SATURATION = 0x14,
+    DISP_CMD_GET_BRIGHT = 0x16,
+    DISP_CMD_GET_CONTRAST = 0x17,
+    DISP_CMD_GET_SATURATION = 0x18,
+    DISP_CMD_ENHANCE_ON = 0x1a,
+    DISP_CMD_ENHANCE_OFF = 0x1b,
+    DISP_CMD_GET_ENHANCE_EN = 0x1c,
+    DISP_CMD_CLK_ON = 0x1d,
+    DISP_CMD_CLK_OFF = 0x1e,
+    DISP_CMD_SET_SCREEN_SIZE = 0x1f,//when the screen is not used to display(lcd/tv/vga/hdmi) directly, maybe capture the screen and scaler to dram, or as a layer of another screen
+    DISP_CMD_CAPTURE_SCREEN = 0x20,//caputre screen and scaler to dram
+
+//----layer----
+    DISP_CMD_LAYER_REQUEST = 0x40,
+    DISP_CMD_LAYER_RELEASE = 0x41,
+    DISP_CMD_LAYER_OPEN = 0x42,
+    DISP_CMD_LAYER_CLOSE = 0x43,
+    DISP_CMD_LAYER_SET_FB = 0x44,
+    DISP_CMD_LAYER_GET_FB = 0x45,
+    DISP_CMD_LAYER_SET_SRC_WINDOW = 0x46,
+    DISP_CMD_LAYER_GET_SRC_WINDOW = 0x47,
+    DISP_CMD_LAYER_SET_SCN_WINDOW = 0x48,
+    DISP_CMD_LAYER_GET_SCN_WINDOW = 0x49,
+    DISP_CMD_LAYER_SET_PARA = 0x4a,
+    DISP_CMD_LAYER_GET_PARA = 0x4b,
+    DISP_CMD_LAYER_ALPHA_ON = 0x4c,
+    DISP_CMD_LAYER_ALPHA_OFF = 0x4d,
+    DISP_CMD_LAYER_GET_ALPHA_EN = 0x4e,
+    DISP_CMD_LAYER_SET_ALPHA_VALUE = 0x4f,
+    DISP_CMD_LAYER_GET_ALPHA_VALUE = 0x50,
+    DISP_CMD_LAYER_CK_ON = 0x51,
+    DISP_CMD_LAYER_CK_OFF = 0x52,
+    DISP_CMD_LAYER_GET_CK_EN = 0x53,
+    DISP_CMD_LAYER_SET_PIPE = 0x54,
+    DISP_CMD_LAYER_GET_PIPE = 0x55,
+    DISP_CMD_LAYER_TOP = 0x56,
+    DISP_CMD_LAYER_BOTTOM = 0x57,
+    DISP_CMD_LAYER_GET_PRIO = 0x58,
+    DISP_CMD_LAYER_SET_SMOOTH = 0x59,
+    DISP_CMD_LAYER_GET_SMOOTH = 0x5a,
+    DISP_CMD_LAYER_SET_BRIGHT = 0x5b,//亮度
+    DISP_CMD_LAYER_SET_CONTRAST = 0x5c,//对比度
+    DISP_CMD_LAYER_SET_SATURATION = 0x5d,//饱和度
+    DISP_CMD_LAYER_SET_HUE = 0x5e,//色调,色度
+    DISP_CMD_LAYER_GET_BRIGHT = 0x5f,
+    DISP_CMD_LAYER_GET_CONTRAST = 0x60,
+    DISP_CMD_LAYER_GET_SATURATION = 0x61,
+    DISP_CMD_LAYER_GET_HUE = 0x62,
+    DISP_CMD_LAYER_ENHANCE_ON = 0x63,
+    DISP_CMD_LAYER_ENHANCE_OFF = 0x64,
+    DISP_CMD_LAYER_GET_ENHANCE_EN = 0x65,
+    DISP_CMD_LAYER_VPP_ON = 0x67,
+    DISP_CMD_LAYER_VPP_OFF = 0x68,
+    DISP_CMD_LAYER_GET_VPP_EN = 0x69,
+    DISP_CMD_LAYER_SET_LUMA_SHARP_LEVEL = 0x6a,
+    DISP_CMD_LAYER_GET_LUMA_SHARP_LEVEL = 0x6b,
+    DISP_CMD_LAYER_SET_CHROMA_SHARP_LEVEL = 0x6c,
+    DISP_CMD_LAYER_GET_CHROMA_SHARP_LEVEL = 0x6d,
+    DISP_CMD_LAYER_SET_WHITE_EXTERN_LEVEL = 0x6e,
+    DISP_CMD_LAYER_GET_WHITE_EXTERN_LEVEL = 0x6f,
+    DISP_CMD_LAYER_SET_BLACK_EXTERN_LEVEL = 0x70,
+    DISP_CMD_LAYER_GET_BLACK_EXTERN_LEVEL = 0x71,
+
+//----scaler----
+    DISP_CMD_SCALER_REQUEST = 0x80,
+    DISP_CMD_SCALER_RELEASE = 0x81,
+    DISP_CMD_SCALER_EXECUTE = 0x82,
+
+//----hwc----
+    DISP_CMD_HWC_OPEN = 0xc0,
+    DISP_CMD_HWC_CLOSE = 0xc1,
+    DISP_CMD_HWC_SET_POS = 0xc2,
+    DISP_CMD_HWC_GET_POS = 0xc3,
+    DISP_CMD_HWC_SET_FB = 0xc4,
+    DISP_CMD_HWC_SET_PALETTE_TABLE = 0xc5,
+
+//----video----
+    DISP_CMD_VIDEO_START = 0x100,
+    DISP_CMD_VIDEO_STOP = 0x101,
+    DISP_CMD_VIDEO_SET_FB = 0x102,
+    DISP_CMD_VIDEO_GET_FRAME_ID = 0x103,
+    DISP_CMD_VIDEO_GET_DIT_INFO = 0x104,
+
+//----lcd----
+    DISP_CMD_LCD_ON = 0x140,
+    DISP_CMD_LCD_OFF = 0x141,
+    DISP_CMD_LCD_SET_BRIGHTNESS = 0x142,
+    DISP_CMD_LCD_GET_BRIGHTNESS = 0x143,
+    DISP_CMD_LCD_SET_COLOR = 0x144,
+    DISP_CMD_LCD_GET_COLOR = 0x145,
+    DISP_CMD_LCD_CPUIF_XY_SWITCH = 0x146,
+    DISP_CMD_LCD_CHECK_OPEN_FINISH = 0x14a,
+    DISP_CMD_LCD_CHECK_CLOSE_FINISH = 0x14b,
+    DISP_CMD_LCD_SET_SRC = 0x14c,
+
+//----tv----
+    DISP_CMD_TV_ON = 0x180,
+    DISP_CMD_TV_OFF = 0x181,
+    DISP_CMD_TV_SET_MODE = 0x182,
+    DISP_CMD_TV_GET_MODE = 0x183,
+    DISP_CMD_TV_AUTOCHECK_ON = 0x184,
+    DISP_CMD_TV_AUTOCHECK_OFF = 0x185,
+    DISP_CMD_TV_GET_INTERFACE = 0x186,
+    DISP_CMD_TV_SET_SRC = 0x187,
+    DISP_CMD_TV_GET_DAC_STATUS = 0x188,
+    DISP_CMD_TV_SET_DAC_SOURCE = 0x189,
+    DISP_CMD_TV_GET_DAC_SOURCE = 0x18a,
+
+//----hdmi----
+    DISP_CMD_HDMI_ON = 0x1c0,
+    DISP_CMD_HDMI_OFF = 0x1c1,
+    DISP_CMD_HDMI_SET_MODE = 0x1c2,
+    DISP_CMD_HDMI_GET_MODE = 0x1c3,
+    DISP_CMD_HDMI_SUPPORT_MODE = 0x1c4,
+    DISP_CMD_HDMI_GET_HPD_STATUS = 0x1c5,
+	DISP_CMD_HDMI_SET_SRC = 0x1c6,
+
+//----vga----
+    DISP_CMD_VGA_ON = 0x200,
+    DISP_CMD_VGA_OFF = 0x201,
+    DISP_CMD_VGA_SET_MODE = 0x202,
+    DISP_CMD_VGA_GET_MODE = 0x203,
+	DISP_CMD_VGA_SET_SRC = 0x204,
+
+//----sprite----
+    DISP_CMD_SPRITE_OPEN = 0x240,
+    DISP_CMD_SPRITE_CLOSE = 0x241,
+    DISP_CMD_SPRITE_SET_FORMAT = 0x242,
+    DISP_CMD_SPRITE_GLOBAL_ALPHA_ENABLE = 0x243,
+    DISP_CMD_SPRITE_GLOBAL_ALPHA_DISABLE = 0x244,
+    DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_ENABLE = 0x252,
+    DISP_CMD_SPRITE_SET_GLOBAL_ALPHA_VALUE = 0x245,
+    DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_VALUE = 0x253,
+    DISP_CMD_SPRITE_SET_ORDER = 0x246,
+    DISP_CMD_SPRITE_GET_TOP_BLOCK = 0x250,
+    DISP_CMD_SPRITE_GET_BOTTOM_BLOCK = 0x251,
+    DISP_CMD_SPRITE_SET_PALETTE_TBL = 0x247,
+    DISP_CMD_SPRITE_GET_BLOCK_NUM = 0x259,
+    DISP_CMD_SPRITE_BLOCK_REQUEST = 0x248,
+    DISP_CMD_SPRITE_BLOCK_RELEASE = 0x249,
+    DISP_CMD_SPRITE_BLOCK_OPEN = 0x257,
+    DISP_CMD_SPRITE_BLOCK_CLOSE = 0x258,
+    DISP_CMD_SPRITE_BLOCK_SET_SOURCE_WINDOW = 0x25a,
+    DISP_CMD_SPRITE_BLOCK_GET_SOURCE_WINDOW = 0x25b,
+    DISP_CMD_SPRITE_BLOCK_SET_SCREEN_WINDOW = 0x24a,
+    DISP_CMD_SPRITE_BLOCK_GET_SCREEN_WINDOW = 0x24c,
+    DISP_CMD_SPRITE_BLOCK_SET_FB = 0x24b,
+    DISP_CMD_SPRITE_BLOCK_GET_FB = 0x24d,
+    DISP_CMD_SPRITE_BLOCK_SET_PARA = 0x25c,
+    DISP_CMD_SPRITE_BLOCK_GET_PARA = 0x25d,
+    DISP_CMD_SPRITE_BLOCK_SET_TOP = 0x24e,
+    DISP_CMD_SPRITE_BLOCK_SET_BOTTOM = 0x24f,
+    DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK = 0x254,
+    DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK = 0x255,
+    DISP_CMD_SPRITE_BLOCK_GET_PRIO = 0x256,
+
+//----framebuffer----
+	DISP_CMD_FB_REQUEST = 0x280,
+	DISP_CMD_FB_RELEASE = 0x281,
+	
+//---for Displayer Test --------	
+	DISP_CMD_MEM_REQUEST = 0x2c0,
+	DISP_CMD_MEM_RELASE = 0x2c1,
+	DISP_CMD_MEM_GETADR = 0x2c2,
+	DISP_CMD_MEM_SELIDX = 0x2c3,
+	
+	DISP_CMD_SUSPEND = 0x2c4,
+	DISP_CMD_RESUME = 0x2c5,
+	 
+
+}__disp_cmd_t;
+
+#define FBIOGET_LAYER_HDL 0x4700
+#define FBIO_CLOSE 0x4701
+#define FBIO_OPEN 0x4702
+#define FBIO_ALPHA_ON 0x4703
+#define FBIO_ALPHA_OFF 0x4704
+#define FBIOPUT_ALPHA_VALUE 0x4705
+#define FBIO_DISPLAY_SCREEN0_ONLY 0x4706 //used when dual screen mode
+#define FBIO_DISPLAY_SCREEN1_ONLY 0x4707 //used when dual screen mode
+#define FBIO_DISPLAY_DUAL_SCREEN 0x4708 //used when dual screen mode
+
+#endif
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/g2d_driver.h DirectFB-1.4.11/gfxdrivers/vmware/g2d_driver.h
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/g2d_driver.h	1970-01-01 08:00:00.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/g2d_driver.h	2011-07-20 14:04:17.063702000 +0800
@@ -0,0 +1,233 @@
+/* g2d_driver.h
+ *
+ * Copyright (c)	2011 xxxx Electronics
+ *					2011 Yupu Tang
+ *
+ * @ F23 G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ */
+
+#ifndef __G2D_DRIVER_H
+#define __G2D_DRIVER_H
+
+#ifndef __G2D_BSP_DRV_H
+#define __G2D_BSP_DRV_H
+
+/* mixer data format */
+typedef enum {
+	/* share data format */
+	G2D_FMT_ARGB_AYUV8888	= (0x0),
+	G2D_FMT_BGRA_VUYA8888	= (0x1),
+	G2D_FMT_ABGR_AVUY8888	= (0x2),
+	G2D_FMT_RGBA_YUVA8888	= (0x3),
+	
+	G2D_FMT_XRGB8888		= (0x4),
+	G2D_FMT_BGRX8888		= (0x5),
+	G2D_FMT_XBGR8888		= (0x6),
+	G2D_FMT_RGBX8888		= (0x7),
+	
+	G2D_FMT_ARGB4444		= (0x8),
+	G2D_FMT_ABGR4444		= (0x9),
+	G2D_FMT_RGBA4444		= (0xA),
+	G2D_FMT_BGRA4444		= (0xB),
+
+	G2D_FMT_ARGB1555		= (0xC),
+	G2D_FMT_ABGR1555		= (0xD),
+	G2D_FMT_RGBA5551		= (0xE),
+	G2D_FMT_BGRA5551		= (0xF),
+
+	G2D_FMT_RGB565			= (0x10),
+	G2D_FMT_BGR565			= (0x11),
+
+	G2D_FMT_IYUV422			= (0x12),
+
+	G2D_FMT_8BPP_MONO		= (0x13),
+	G2D_FMT_4BPP_MONO		= (0x14),
+	G2D_FMT_2BPP_MONO		= (0x15),
+	G2D_FMT_1BPP_MONO		= (0x16),
+
+	G2D_FMT_PYUV422UVC		= (0x17),
+	G2D_FMT_PYUV420UVC		= (0x18),
+	G2D_FMT_PYUV411UVC		= (0x19),
+	
+	/* just for output format */
+	G2D_FMT_PYUV422			= (0x1A),
+	G2D_FMT_PYUV420			= (0x1B),
+	G2D_FMT_PYUV411			= (0x1C),
+	
+	/* just for input format */	
+	G2D_FMT_8BPP_PALETTE	= (0x1D),
+	G2D_FMT_4BPP_PALETTE	= (0x1E),
+	G2D_FMT_2BPP_PALETTE	= (0x1F),
+	G2D_FMT_1BPP_PALETTE	= (0x20),
+			
+}g2d_data_fmt;	
+
+/* pixel sequence in double word */
+typedef enum {
+            
+	/* for interleaved yuv422 */
+    G2D_SEQ_VYUY   = 0x0,				/* pixel 0在低16位 */
+    G2D_SEQ_YVYU   = 0x1,				/* pixel 1在低16位 */
+    
+	/* for uv_combined yuv420 */
+    G2D_SEQ_VUVU   = 0x2,  
+    
+	/* for 16bpp rgb */
+    G2D_SEQ_P10    = 0x3,				/* pixel 0在低16位 */
+    G2D_SEQ_P01    = 0x4,				/* pixel 1在低16位 */
+    
+	/* planar format or 8bpp rgb */
+    G2D_SEQ_P3210  = 0x5,				/* pixel 0在低8位 */
+    G2D_SEQ_P0123  = 0x6,				/* pixel 3在低8位 */
+    
+	/* for 4bpp rgb */
+    G2D_SEQ_P76543210  = 0x7,			/* 7,6,5,4,3,2,1,0 */
+    G2D_SEQ_P67452301  = 0x8,			/* 6,7,4,5,2,3,0,1 */
+    G2D_SEQ_P10325476  = 0x9,			/* 1,0,3,2,5,4,7,6 */
+    G2D_SEQ_P01234567  = 0xA,			/* 0,1,2,3,4,5,6,7 */
+    
+	/* for 2bpp rgb */
+    G2D_SEQ_2BPP_BIG_BIG       = 0xB,	/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+    G2D_SEQ_2BPP_BIG_LITTER    = 0xC,	/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */
+    G2D_SEQ_2BPP_LITTER_BIG    = 0xD,	/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */
+    G2D_SEQ_2BPP_LITTER_LITTER = 0xE,	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */
+    
+	/* for 1bpp rgb */
+    G2D_SEQ_1BPP_BIG_BIG       = 0xF,	/* 31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+    G2D_SEQ_1BPP_BIG_LITTER    = 0x10,	/* 24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7 */
+    G2D_SEQ_1BPP_LITTER_BIG    = 0x11,	/* 7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24 */
+    G2D_SEQ_1BPP_LITTER_LITTER = 0x12,	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 */
+}g2d_pixel_seq;
+
+typedef enum {
+	
+	G2D_EFFECT_NONE		= 0x0,
+	G2D_PIXEL_ALPHA		= 0x01,
+	G2D_PLANE_ALPHA		= 0x02,
+	G2D_MULTI_ALPHA		= 0x04,	
+	G2D_SRC_COLORKEY	= 0x08,
+	G2D_DST_COLORKEY	= 0x10,
+
+}g2d_effect_flag;
+
+typedef enum {
+	
+	G2D_TRANSFORM_NONE	= 0x0,		
+	G2D_FLIP_HORIZONTAL	= 0x10,
+	G2D_FLIP_VERTICAL	= 0x20,	
+	G2D_ROTATE180		= 0x30,
+	G2D_MIRROR135		= 0x40,
+	G2D_ROTATE90		= 0x50,		
+	G2D_ROTATE270		= 0x60,
+	G2D_MIRROR45		= 0x70,
+
+}g2d_transform_flag;
+
+/* flip rectangle struct */
+typedef struct {
+	__s32		x;			/* left top point coordinate x */
+	__s32		y;			/* left top point coordinate y */
+	__u32		w;			/* rectangle width */
+	__u32		h;			/* rectangle height */
+}g2d_rect;
+
+/* image struct */
+typedef struct {
+	__u32			 addr[3];	/* base addr of image frame buffer in byte */
+	__u32			 w;			/* width of image frame buffer in pixel */
+	__u32			 h;			/* height of image frame buffer in pixel */
+	g2d_data_fmt	 format;	/* pixel format of image frame buffer */
+	g2d_pixel_seq	 pixel_seq;	/* pixel sequence of image frame buffer */
+}g2d_image;
+	
+typedef struct {
+	g2d_effect_flag		 flag;
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+		
+	__u32				 color;		/* fill color */
+	__u32				 alpha;		/* plane alpha value */
+		
+}g2d_fillrect;
+
+typedef struct {
+	g2d_effect_flag		 flag0;
+	g2d_transform_flag	 flag1;	
+	g2d_image			 src_image;                        
+	g2d_rect			 src_rect;
+	
+	g2d_image			 dst_image;	
+	__s32				 dst_x;		/* left top point coordinate x of dst rect */
+	__s32				 dst_y;		/* left top point coordinate y of dst rect */
+	
+	__u32				 color;		/* colorkey color */	
+	__u32				 alpha;		/* plane alpha value */
+
+}g2d_blt;
+
+typedef struct {
+	g2d_effect_flag		 flag0;
+	g2d_transform_flag	 flag1;
+	g2d_image			 src_image;
+	g2d_rect			 src_rect;
+	
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+	
+	__u32				 color;		/* colorkey color */	
+	__u32				 alpha;		/* plane alpha value */
+	
+}g2d_stretchblt;
+
+typedef struct {
+	__u32		 flag;		/* 光栅操作码 */
+	g2d_image	 dst_image;
+	g2d_rect	 dst_rect;
+		
+	g2d_image	 src_image;
+	__u32		 src_x;
+	__u32		 src_y;
+	
+	g2d_image	 mask_image;
+	__u32		 mask_x;
+	__u32		 mask_y;
+	
+}g2d_maskblt;
+
+typedef struct {
+	__u32		*pbuffer;
+	__u32		 size;
+	
+}g2d_palette;
+
+#endif /*__G2D_BSP_DRV_H*/
+
+typedef enum
+{
+	G2D_CMD_BITBLT			=	0x50,
+	G2D_CMD_FILLRECT		=	0x51,
+	G2D_CMD_STRETCHBLT		=	0x52,
+	G2D_CMD_PALETTE_TBL		=	0x53,
+	
+	G2D_CMD_MEM_REQUEST		=	0x59,
+	G2D_CMD_MEM_RELEASE		=	0x5A,
+	G2D_CMD_MEM_GETADR		=	0x5B,
+	G2D_CMD_MEM_SELIDX		=	0x5C,
+}g2d_cmd;
+
+#endif	/* __G2D_DRIVER_H */
+
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/Makefile.am DirectFB-1.4.11/gfxdrivers/vmware/Makefile.am
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/Makefile.am	2010-10-31 16:49:49.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/Makefile.am	2011-06-10 19:12:16.698708000 +0800
@@ -19,6 +19,7 @@
 libdirectfb_vmware_la_SOURCES =	\
 	vmware_2d.c		\
 	vmware_2d.h		\
+	vmware_surface_pool.c \	
 	vmware_gfxdriver.c	\
 	vmware_gfxdriver.h
 
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/Makefile.in DirectFB-1.4.11/gfxdrivers/vmware/Makefile.in
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/Makefile.in	2010-11-16 05:35:40.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/Makefile.in	2011-05-30 15:02:50.029558000 +0800
@@ -76,7 +76,7 @@
 libdirectfb_vmware_la_DEPENDENCIES =  \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/src/libdirectfb.la
-am_libdirectfb_vmware_la_OBJECTS = vmware_2d.lo vmware_gfxdriver.lo
+am_libdirectfb_vmware_la_OBJECTS = vmware_2d.lo vmware_surface_pool.lo vmware_gfxdriver.lo
 libdirectfb_vmware_la_OBJECTS = $(am_libdirectfb_vmware_la_OBJECTS)
 libdirectfb_vmware_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
@@ -193,7 +193,6 @@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MAN2HTML = @MAN2HTML@
-MEDIALIB = @MEDIALIB@
 MKDIR_P = @MKDIR_P@
 MODULEDIR = @MODULEDIR@
 MODULEDIRNAME = @MODULEDIRNAME@
@@ -311,6 +310,7 @@
 libdirectfb_vmware_la_SOURCES = \
 	vmware_2d.c		\
 	vmware_2d.h		\
+	vmware_surface_pool.c \
 	vmware_gfxdriver.c	\
 	vmware_gfxdriver.h
 
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_2d.c DirectFB-1.4.11/gfxdrivers/vmware/vmware_2d.c
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_2d.c	2010-11-16 05:13:05.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/vmware_2d.c	2011-07-20 14:02:35.476541000 +0800
@@ -16,13 +16,24 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the
-   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
    Boston, MA 02111-1307, USA.
 */
 
 //#define DIRECT_ENABLE_DEBUG
 
 #include <config.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <fbdev/fb.h>
+
+#include <asm/types.h>
 
 #include <directfb.h>
 
@@ -34,10 +45,16 @@
 #include <core/surface.h>
 
 #include <gfx/convert.h>
+#include <sys/ioctl.h>
 
 #include "vmware_2d.h"
 #include "vmware_gfxdriver.h"
+#include "drv_display_sun4i.h"
+#include "g2d_driver.h"
 
+extern int   hmp;
+unsigned int mpmem[100];
+unsigned int fbdata[3];
 
 D_DEBUG_DOMAIN( VMWare_2D, "VMWare/2D", "VMWare 2D Acceleration" );
 
@@ -67,8 +84,9 @@
                                                 vmware_validate_##flag( vdev, state );  \
                                       } while (0)
 
-
 /**************************************************************************************************/
+static unsigned int vmware_get_paddr(unsigned int vaddr);
+static unsigned int wmware_get_color_format(unsigned int dfb_format);										   
 
 /*
  * Called by vmwareSetState() to ensure that the destination registers are properly set
@@ -80,9 +98,12 @@
 {
      /* Remember destination parameters for usage in rendering functions. */
      vdev->dst_addr   = state->dst.addr;
+	 vdev->dst_paddr  = state->dst.phys;
      vdev->dst_pitch  = state->dst.pitch;
      vdev->dst_format = state->dst.buffer->format;
      vdev->dst_bpp    = DFB_BYTES_PER_PIXEL( vdev->dst_format );
+	 vdev->dst_width  = state->dst.pitch/4;//state->destination->config.size.w;
+	 vdev->dst_height = state->destination->config.size.h;
 
      /* Set the flag. */
      VMWARE_VALIDATE( DESTINATION );
@@ -116,10 +137,39 @@
                                                 state->color.b );
                break;
 
+		   case DSPF_ARGB4444:
+				vdev->color_pixel = PIXEL_ARGB4444( state->color.a,
+													state->color.r,
+													state->color.g,
+													state->color.b );
+				break;
+		   
+		   case DSPF_RGBA4444:
+				vdev->color_pixel = PIXEL_RGBA4444( state->color.a,
+												 	state->color.r,
+												 	state->color.g,
+												 	state->color.b );
+				break;
+		   
+		   case DSPF_ARGB1555:
+				vdev->color_pixel = PIXEL_ARGB1555( state->color.a,
+					                             	state->color.r,
+												 	state->color.g,
+												 	state->color.b ); 
+				break;
+				
+		   case DSPF_RGBA5551:
+				vdev->color_pixel = PIXEL_RGBA5551( state->color.a,
+												  	state->color.r,
+												  	state->color.g,
+												  	state->color.b ); 
+				 break;
+				 
           default:
                D_BUG( "unexpected format %s", dfb_pixelformat_name(vdev->dst_format) );
      }
 
+	 vdev->alpha = state->color.a;
      /* Set the flag. */
      VMWARE_VALIDATE( COLOR );
 }
@@ -133,10 +183,14 @@
                         CardState        *state )
 {
      /* Remember source parameters for usage in rendering functions. */
-     vdev->src_addr   = state->src.addr;
-     vdev->src_pitch  = state->src.pitch;
-     vdev->src_format = state->src.buffer->format;
-     vdev->src_bpp    = DFB_BYTES_PER_PIXEL( vdev->src_format );
+     vdev->src_addr     = state->src.addr;
+	 vdev->src_paddr  	= state->src.phys;
+     vdev->src_pitch    = state->src.pitch;
+     vdev->src_format   = state->src.buffer->format;
+     vdev->src_bpp      = DFB_BYTES_PER_PIXEL( vdev->src_format );
+     vdev->src_colorkey = state->src_colorkey;
+	 vdev->src_width    = state->src.pitch/4;//state->source->config.size.w;
+	 vdev->src_height   = state->source->config.size.h;
 
      /* Set the flag. */
      VMWARE_VALIDATE( SOURCE );
@@ -155,6 +209,7 @@
 DFBResult
 vmwareEngineSync( void *drv, void *dev )
 {
+
      return DFB_OK;
 }
 
@@ -164,6 +219,7 @@
 void
 vmwareEngineReset( void *drv, void *dev )
 {
+
 }
 
 /*
@@ -177,6 +233,7 @@
 void
 vmwareEmitCommands( void *drv, void *dev )
 {
+
 }
 
 /*
@@ -188,47 +245,67 @@
                   CardState           *state,
                   DFBAccelerationMask  accel )
 {
+     VMWareDeviceData       *vdev     = (VMWareDeviceData*) dev;
+
      D_DEBUG_AT( VMWare_2D, "vmwareCheckState (state %p, accel 0x%08x) <- dest %p\n",
                  state, accel, state->destination );
 
      /* Return if the desired function is not supported at all. */
-     if (accel & ~(VMWARE_SUPPORTED_DRAWINGFUNCTIONS | VMWARE_SUPPORTED_BLITTINGFUNCTIONS))
+     if (accel & ~(VMWARE_SUPPORTED_DRAWINGFUNCTIONS | VMWARE_SUPPORTED_BLITTINGFUNCTIONS)){
           return;
+        }
 
      /* Return if the destination format is not supported. */
      switch (state->destination->config.format) {
           case DSPF_ARGB:
           case DSPF_RGB32:
           case DSPF_RGB16:
-               break;
+          case DSPF_ARGB4444:
+          case DSPF_RGBA4444:
+          case DSPF_ARGB1555:
+          case DSPF_RGBA5551:
+          	break;
 
-          default:
-               return;
+          default:{
+          		state->destination->config.format =DSPF_ARGB;
+               break;
+           }
      }
 
      /* Check if drawing or blitting is requested. */
      if (DFB_DRAWING_FUNCTION( accel )) {
           /* Return if unsupported drawing flags are set. */
-          if (state->drawingflags & ~VMWARE_SUPPORTED_DRAWINGFLAGS)
+          if (state->drawingflags & ~VMWARE_SUPPORTED_DRAWINGFLAGS){
+
                return;
+            }
+            vdev->drawingflags = state->drawingflags;
      }
      else {
           /* Return if the source format is not supported. */
           switch (state->source->config.format) {
-               case DSPF_ARGB:
-               case DSPF_RGB32:
-               case DSPF_RGB16:
-                    /* FIXME: Currently only copying blits supported. */
-                    if (state->source->config.format == state->destination->config.format)
-                         break;
+	          case DSPF_ARGB:
+	          case DSPF_RGB32:
+	          case DSPF_RGB16:
+	          case DSPF_ARGB4444:
+	          case DSPF_RGBA4444:
+	          case DSPF_ARGB1555:
+	          case DSPF_RGBA5551:
+
+			    /* FIXME: Currently only copying blits supported. */
+//			    if (state->source->config.format == state->destination->config.format)
+			         break;
 
-               default:
-                    return;
+              default:{
+						return;
+               }
           }
 
           /* Return if unsupported blitting flags are set. */
-          if (state->blittingflags & ~VMWARE_SUPPORTED_BLITTINGFLAGS)
+          if (state->blittingflags & ~VMWARE_SUPPORTED_BLITTINGFLAGS){
                return;
+            }
+            vdev->blittingflags = state->blittingflags;            
      }
 
      /* Enable acceleration of the function. */
@@ -297,6 +374,7 @@
 
           case DFXL_BLIT:
                /* ...require valid source. */
+			   VMWARE_CHECK_VALIDATE( COLOR );
                VMWARE_CHECK_VALIDATE( SOURCE );
 
                /*
@@ -307,6 +385,20 @@
                state->set = VMWARE_SUPPORTED_BLITTINGFUNCTIONS;
                break;
 
+          case DFXL_STRETCHBLIT:
+               /* ...require valid source. */
+			   VMWARE_CHECK_VALIDATE( COLOR );
+               VMWARE_CHECK_VALIDATE( SOURCE );
+
+               /*
+                * 3) Tell which functions can be called without further validation, i.e. SetState()
+                *
+                * When the hw independent state is changed, this collection is reset.
+                */
+               state->set = VMWARE_SUPPORTED_BLITTINGFUNCTIONS;
+              
+               break;
+               
           default:
                D_BUG( "unexpected drawing/blitting function" );
                break;
@@ -320,6 +412,7 @@
       * for subsequent rendering functions, unless they aren't defined by 3).
       */
      state->mod_hw = 0;
+
 }
 
 /*
@@ -328,75 +421,276 @@
 bool
 vmwareFillRectangle( void *drv, void *dev, DFBRectangle *rect )
 {
-     VMWareDeviceData *vdev = (VMWareDeviceData*) dev;
-     void             *addr = vdev->dst_addr + rect->y * vdev->dst_pitch +
-                              DFB_BYTES_PER_LINE(vdev->dst_format, rect->x);
-
-     D_DEBUG_AT( VMWare_2D, "%s( %d,%d-%dx%d )\n", __FUNCTION__, DFB_RECTANGLE_VALS( rect ) );
-
-     switch (vdev->dst_bpp) {
-          case 4:
-               while (rect->h--) {
-                    int  w   = rect->w;
-                    u32 *dst = addr;
-
-                    while (w--)
-                         *dst++ = vdev->color_pixel;
-
-                    addr += vdev->dst_pitch;
-               }
-               break;
-
-          case 2:
-               while (rect->h--) {
-                    int  w   = rect->w;
-                    u16 *dst = addr;
-
-                    while (w--)
-                         *dst++ = vdev->color_pixel;
-
-                    addr += vdev->dst_pitch;
-               }
-               break;
-
-          case 1:
-               while (rect->h--) {
-                    int  w   = rect->w;
-                    u8  *dst = addr;
-
-                    while (w--)
-                         *dst++ = vdev->color_pixel;
-
-                    addr += vdev->dst_pitch;
-               }
-               break;
-     }
 
+     VMWareDeviceData *vdev     = (VMWareDeviceData*) dev;
+     unsigned int dst_phy_addr  = 0;
+     unsigned int dst_color_f   = 0;
+	 unsigned long arg[2];	 	 
+	 g2d_fillrect fill_para;
+
+	 if(hmp == NULL)
+	 {
+	 	 printf("[jshwang][%d][%s][%s]\n", __LINE__, __FILE__,__FUNCTION__);
+		 return false;
+	 }
+
+	 dst_phy_addr =(unsigned int)vdev->dst_paddr;
+	 if((dst_phy_addr == 0))
+	 {
+	 	  printf("[jshwang][%d][%s][%s]\n", __LINE__, __FILE__,__FUNCTION__);
+		  return false;
+	 }
+	 dst_color_f = wmware_get_color_format((unsigned int)vdev->dst_format );
+
+	 if (vdev->drawingflags & DSDRAW_BLEND		){fill_para.flag = G2D_PLANE_ALPHA;}	
+	 else if (vdev->drawingflags & DSDRAW_NOFX	){fill_para.flag = G2D_EFFECT_NONE;}
+	 fill_para.dst_image.addr[0]   = dst_phy_addr;
+	 fill_para.dst_image.w         = vdev->dst_width;      //set dst width
+	 fill_para.dst_image.h         = vdev->dst_height;     //set dst height
+	 fill_para.dst_image.format    = dst_color_f;          //G2D_FMT_RGB565;//(unsigned int)vdev->dst_format;
+	 fill_para.dst_image.pixel_seq = 0;                    //no support color seq,so use 0
+	 fill_para.dst_rect.x          = rect->x;
+	 fill_para.dst_rect.y          = rect->y;
+	 fill_para.dst_rect.w          = rect->w;
+	 fill_para.dst_rect.h          = rect->h;
+	 fill_para.color               = vdev->color_pixel;    //set the color
+     fill_para.alpha               = vdev->alpha;          //set alpha
+	 
+	 arg[0] = (unsigned long)&fill_para;
+	 arg[1] = 0;
+
+	 if(ioctl( hmp , G2D_CMD_FILLRECT ,(void*)arg) < 0)
+	 {
+	 	printf("[vmware][%d][%s][%s]G2D_CMD_FILLRECT failure!\n",__LINE__, __FILE__,__FUNCTION__);
+	 	return false;
+	 }
+	 
      return true;
 }
 
 /*
- * Blit a surface using the current hardware state.
+ * Render a filled rectangle using the current hardware state.
  */
 bool
 vmwareBlit( void *drv, void *dev, DFBRectangle *srect, int dx, int dy )
-{
-     VMWareDeviceData *vdev = (VMWareDeviceData*) dev;
-     void             *dst  = vdev->dst_addr + dy * vdev->dst_pitch +
-                              DFB_BYTES_PER_LINE(vdev->dst_format, dx);
-     void             *src  = vdev->src_addr + srect->y * vdev->src_pitch +
-                              DFB_BYTES_PER_LINE(vdev->src_format, srect->x);
+{ 
+    VMWareDeviceData *vdev    = (VMWareDeviceData*) dev;                     
+    u32 src_colorkey          =  vdev->src_colorkey;         
+    unsigned int dst_phy_addr = 0;
+    unsigned int src_phy_addr = 0;
+	unsigned int src_color_f  = 0;
+	unsigned int dst_color_f  = 0;
+	
+	unsigned long  arg[2];	 
+	g2d_blt        blit_para;
+
+    if(hmp == NULL)
+    {
+        return false;
+    }
+	
+    //check dst phy addr
+    dst_phy_addr = (unsigned int)vdev->dst_paddr;
+    src_phy_addr = (unsigned int)vdev->src_paddr;
+
+    if((dst_phy_addr == 0)||(src_phy_addr == 0))
+    {
+		 return false;
+    }
+
+	dst_color_f = wmware_get_color_format((unsigned int)vdev->dst_format );
+	src_color_f = wmware_get_color_format((unsigned int)vdev->src_format );
+	
+	blit_para.src_image.addr[0]      = src_phy_addr;
+	blit_para.src_image.w            = vdev->src_width;
+	blit_para.src_image.h            = vdev->src_height;
+	blit_para.src_image.format       = src_color_f;             //(unsigned int)vdev->dst_format;
+	blit_para.src_image.pixel_seq    = 0;
+	blit_para.src_rect.x             = srect->x;
+	blit_para.src_rect.y             = srect->y;
+	blit_para.src_rect.w             = srect->w;
+	blit_para.src_rect.h             = srect->h;
+	blit_para.dst_image.addr[0]      = dst_phy_addr;
+	blit_para.dst_image.w            = vdev->dst_width;			
+	blit_para.dst_image.h            = vdev->dst_height;
+	blit_para.dst_image.format       = dst_color_f;             //(unsigned int)vdev->dst_format;
+	blit_para.dst_image.pixel_seq    = 0;
+	blit_para.dst_x                  = dx;
+	blit_para.dst_y                  = dy;
+	blit_para.color                  = vdev->src_colorkey;      //set colorkey
+	blit_para.alpha                  = vdev->alpha;
+
+    if		(vdev->blittingflags & DSBLIT_BLEND_ALPHACHANNEL){blit_para.flag0 = G2D_PIXEL_ALPHA;}
+	else if (vdev->blittingflags & DSBLIT_BLEND_COLORALPHA	){blit_para.flag0 = G2D_PLANE_ALPHA;}
+	else if (vdev->blittingflags & DSBLIT_SRC_COLORKEY		){blit_para.flag0 = G2D_SRC_COLORKEY;}
+	else if (vdev->blittingflags & DSBLIT_DST_COLORKEY		){blit_para.flag0 = G2D_DST_COLORKEY;}	
+	else if (vdev->blittingflags & DSBLIT_NOFX				){blit_para.flag0 = G2D_EFFECT_NONE;}
+
+    if		(vdev->blittingflags & DSBLIT_ROTATE90			){blit_para.flag1 = G2D_ROTATE90;}
+	else if (vdev->blittingflags & DSBLIT_ROTATE270			){blit_para.flag1 = G2D_ROTATE270;}
+	else if (vdev->blittingflags & DSBLIT_ROTATE180			){blit_para.flag1 = G2D_ROTATE180;}		 	
+	else if (vdev->blittingflags & DSBLIT_FLIP_HORIZONTAL	){blit_para.flag1 = G2D_FLIP_HORIZONTAL;}	
+	else if (vdev->blittingflags & DSBLIT_FLIP_VERTICAL		){blit_para.flag1 = G2D_FLIP_VERTICAL;}
+	else													 {blit_para.flag1 = G2D_TRANSFORM_NONE;}
+
+	arg[0] = (unsigned long)&blit_para;
+	arg[1] = 0;
+	
+	if(ioctl(hmp , G2D_CMD_BITBLT ,(void *)arg ) < 0)
+	{
+		
+   		printf("[vmware][%d][%s][%s]G2D_CMD_BITBLT failure!\n",__LINE__, __FILE__,__FUNCTION__);
+		return false;
+	}
+	
+    return true;
+}
 
-     D_DEBUG_AT( VMWare_2D, "%s( %d,%d-%dx%d -> %d, %d )\n", __FUNCTION__,
-                 DFB_RECTANGLE_VALS( srect ), dx, dy );
+bool vmwareStretchBlit( void *drv, void *dev,DFBRectangle *srect, DFBRectangle *drect )
+{
+	VMWareDeviceData *vdev    = (VMWareDeviceData*) dev;	
+	unsigned int src_phy_addr = 0;
+	unsigned int dst_phy_addr = 0;
+	unsigned int src_color_f  = 0;
+	unsigned int dst_color_f  = 0;
+	unsigned long arg[2];	
+	g2d_stretchblt  stretchblit_para;
+	
+    if(hmp == NULL)
+    {
+        return false;
+    }
+
+    dst_phy_addr = (unsigned int)vdev->dst_paddr;
+    src_phy_addr = (unsigned int)vdev->src_paddr;
+
+    if((dst_phy_addr == 0)||(src_phy_addr == 0))
+    {
+		 return false;
+    }
+
+	dst_color_f = wmware_get_color_format((unsigned int)vdev->dst_format );
+	src_color_f = wmware_get_color_format((unsigned int)vdev->src_format );
+	
+    stretchblit_para.src_image.addr[0]       = src_phy_addr;
+    stretchblit_para.src_image.w             = vdev->src_width;
+    stretchblit_para.src_image.h             = vdev->src_height;
+    stretchblit_para.src_image.format        = src_color_f;
+    stretchblit_para.src_image.pixel_seq     = 0;
+   
+    stretchblit_para.src_rect.x              = srect->x;
+    stretchblit_para.src_rect.y              = srect->y;
+    stretchblit_para.src_rect.w              = srect->w;
+    stretchblit_para.src_rect.h              = srect->h;
+
+    stretchblit_para.dst_image.addr[0]       = dst_phy_addr;
+    stretchblit_para.dst_image.w             = vdev->dst_width;
+    stretchblit_para.dst_image.h             = vdev->dst_height;
+    stretchblit_para.dst_image.format        = dst_color_f;
+    stretchblit_para.dst_image.pixel_seq     = 0;
+   
+    stretchblit_para.dst_rect.x              = drect->x;
+    stretchblit_para.dst_rect.y              = drect->y;
+    stretchblit_para.dst_rect.w              = drect->w;
+    stretchblit_para.dst_rect.h              = drect->h;
+    stretchblit_para.color                   = vdev->src_colorkey;   //set colorkey
+    stretchblit_para.alpha                   = vdev->alpha;//fix me
+    
+    if		(vdev->blittingflags & DSBLIT_BLEND_ALPHACHANNEL){stretchblit_para.flag0 = G2D_PIXEL_ALPHA;}
+	else if (vdev->blittingflags & DSBLIT_BLEND_COLORALPHA	){stretchblit_para.flag0 = G2D_PLANE_ALPHA;}
+	else if (vdev->blittingflags & DSBLIT_SRC_COLORKEY		){stretchblit_para.flag0 = G2D_SRC_COLORKEY;}
+	else if (vdev->blittingflags & DSBLIT_DST_COLORKEY		){stretchblit_para.flag0 = G2D_DST_COLORKEY;}
+	else if (vdev->blittingflags & DSBLIT_NOFX				){stretchblit_para.flag0 = G2D_EFFECT_NONE;}
+
+    if		(vdev->blittingflags & DSBLIT_ROTATE90			){stretchblit_para.flag1 = G2D_ROTATE90;}
+	else if (vdev->blittingflags & DSBLIT_ROTATE270			){stretchblit_para.flag1 = G2D_ROTATE270;}
+	else if (vdev->blittingflags & DSBLIT_ROTATE180			){stretchblit_para.flag1 = G2D_ROTATE180;}		 	
+	else if (vdev->blittingflags & DSBLIT_FLIP_HORIZONTAL	){stretchblit_para.flag1 = G2D_FLIP_HORIZONTAL;}	
+	else if (vdev->blittingflags & DSBLIT_FLIP_VERTICAL		){stretchblit_para.flag1 = G2D_FLIP_VERTICAL;}
+	else													 {stretchblit_para.flag1 = G2D_TRANSFORM_NONE;}
+		
+    arg[0] =(unsigned long)&stretchblit_para;
+    arg[1] = 0;
+
+    if(ioctl(hmp , G2D_CMD_STRETCHBLT ,(void*)arg)<0)
+    {
+   		printf("[vmware][%d][%s][%s]G2D_CMD_STRETCHBLT failure!\n",__LINE__, __FILE__,__FUNCTION__);
+   		return false;
+    }
+   
+    return true;
+   
+}
 
-     while (srect->h--) {
-          direct_memcpy( dst, src, srect->w * vdev->dst_bpp );
+static unsigned int wmware_get_color_format(unsigned int dfb_format)
+{
+	int cf = 0;
 
-          dst += vdev->dst_pitch;
-          src += vdev->src_pitch;
-     }
+	switch(dfb_format)
+	{
+		
+		case DSPF_ARGB:                 /* 32 bit  ARGB (4 byte, alpha 8@24, red 8@16, green 8@8, blue 8@0) */
+		case DSPF_AYUV	:			   /* 32 bit  AYUV (4 byte, alpha 8@24, Y 8@16, Cb 8@8, Cr 8@0) */
+			cf = G2D_FMT_ARGB_AYUV8888;
+			break;	
+			
+		case DSPF_ARGB4444 :			/* 16 bit  ARGB (2 byte, alpha 4@12, red 4@8, green 4@4, blue 4@0) */
+			cf = G2D_FMT_ARGB4444;
+			break;
+			
+		case DSPF_RGBA4444 :			/* 16 bit  RGBA (2 byte, red 4@12, green 4@8, blue 4@4, alpha 4@0) */
+			cf = G2D_FMT_RGBA4444;
+			break;
+
+		case DSPF_ARGB1555:             /* 16 bit  ARGB (2 byte, alpha 1@15, red 5@10, green 5@5, blue 5@0) */
+			cf = G2D_FMT_ARGB1555;
+			break;
+			
+		case DSPF_RGBA5551:            /* 16 bit  RGBA (2 byte, red 5@11, green 5@6, blue 5@1, alpha 1@0) */
+			cf = G2D_FMT_RGBA5551;
+			break;		
+			
+		case DSPF_RGB16:                /* 16 bit	RGB (2 byte, red 5@11, green 6@5, blue 5@0) */
+			cf = G2D_FMT_RGB565;
+			break;		
+			
+		case DSPF_UYVY: 			   /* 16 bit	YUV (4 byte/ 2 pixel, macropixel contains YCbYCr [31:0]) */
+			cf = G2D_FMT_IYUV422;
+			break;
+			
+		case DSPF_RGB24:		       /* 24 bit	RGB (3 byte, red 8@16, green 8@8, blue 8@0) */		
+		case DSPF_RGB32:               /* 24 bit	RGB (4 byte, nothing@24, red 8@16, green 8@8, blue 8@0) */		
+		case DSPF_RGB444 :			   /* 16 bit	RGB (2 byte, nothing @12, red 4@8, green 4@4, blue 4@0) */
+		case DSPF_RGB555  : 		   /* 16 bit	RGB (2 byte, nothing @15, red 5@10, green 5@5, blue 5@0) */ 	
+		case DSPF_BGR555 :			   /* 16 bit	BGR (2 byte, nothing @15, blue 5@10, green 5@5, red 5@0) */
+		case DSPF_NV21	:              /* 12 bit	YUV (8 bit Y plane followed by one 16 bit quarter size Cr|Cb [7:0|7:0] plane) */		
+		case DSPF_A4 :                 /*	4 bit alpha (1 byte/ 2 pixel, more significant nibble used first) */
+		case DSPF_ARGB1666 :           /*	1 bit alpha (3 byte/  alpha 1@18, red 6@12, green 6@6, blue 6@0) */
+        case DSPF_ARGB6666 :           /*	6 bit alpha (3 byte/  alpha 6@18, red 6@12, green 6@6, blue 6@0) */		
+		case DSPF_RGB18	:              /*	6 bit	RGB (3 byte/   red 6@12, green 6@6, blue 6@0) */		
+		case DSPF_LUT2:                /*	2 bit	LUT (1 byte/ 4 pixel, 2 bit color and alpha lookup from palette) */		
+		case DSPF_YUV444P :            /* 24 bit full YUV planar (8 bit Y plane followed by an 8 bit Cb and an 8 bit Cr plane) */
+		case DSPF_A8 :                 /*	8 bit alpha (1 byte, alpha 8@0), e.g. anti-aliased glyphs */			
+		case DSPF_RGB332 :             /*	8 bit	RGB (1 byte, red 3@5, green 3@2, blue 2@0) */
+		case DSPF_YUY2: 			   /* 16 bit	YUV (4 byte/ 2 pixel, macropixel contains CbYCrY [31:0]) */ 
+		case DSPF_I420:                /* 12 bit	YUV (8 bit Y plane followed by 8 bit quarter size U/V planes) */
+		case DSPF_YV12:                /* 12 bit	YUV (8 bit Y plane followed by 8 bit quarter size V/U planes) */
+		case DSPF_LUT8:                /*	8 bit	LUT (8 bit color and alpha lookup from palette) */
+		case DSPF_ALUT44:              /*	8 bit  ALUT (1 byte, alpha 4@4, color lookup 4@0) */
+		case DSPF_AiRGB	:              /* 32 bit  ARGB (4 byte, inv. alpha 8@24, red 8@16, green 8@8, blue 8@0) */
+		case DSPF_A1:                  /*	1 bit alpha (1 byte/ 8 pixel, most significant bit used first) */
+		case DSPF_NV12:                /* 12 bit	YUV (8 bit Y plane followed by one 16 bit quarter size Cb|Cr [7:0|7:0] plane) */
+		case DSPF_NV16:                /* 16 bit	YUV (8 bit Y plane followed by one 16 bit half width Cb|Cr [7:0|7:0] plane) */
+		case DSPF_ARGB2554: 		   /* 16 bit  ARGB (2 byte, alpha 2@14, red 5@9, green 5@4, blue 4@0) */
+		case DSPF_ARGB8565 :           /* 24 bit  ARGB (3 byte, alpha 8@16, red 5@11, green 6@5, blue 5@0) */
+		case DSPF_AVYU:                /* 32 bit  AVYU 4:4:4 (4 byte, alpha 8@24, Cr 8@16, Y 8@8, Cb 8@0) */
+		case DSPF_VYU	:              /* 24 bit	VYU 4:4:4 (3 byte, Cr 8@16, Y 8@8, Cb 8@0) */
+		case DSPF_A1_LSB :             /*	1 bit alpha (1 byte/ 8 pixel, LEAST significant bit used first) */
+		case DSPF_YV16	:              /* 16 bit	YUV (8 bit Y plane followed by 8 bit 2x1 subsampled V/U planes) */
+		case DSPF_UNKNOWN : 		   /* unknown or unspecified format */	
+			break;		
+	
+	}
 
-     return true;
+	return cf;
 }
-
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_2d.h DirectFB-1.4.11/gfxdrivers/vmware/vmware_2d.h
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_2d.h	2010-10-31 16:49:49.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/vmware_2d.h	2011-07-20 14:03:49.768245000 +0800
@@ -23,15 +23,13 @@
 #ifndef __VMWARE_2D_H__
 #define __VMWARE_2D_H__
 
+#define VMWARE_SUPPORTED_DRAWINGFLAGS      (DSDRAW_BLEND)//DSDRAW_NOFX | DSDRAW_BLEND
 
-#define VMWARE_SUPPORTED_DRAWINGFLAGS      (DSDRAW_NOFX)
+#define VMWARE_SUPPORTED_DRAWINGFUNCTIONS  (DFXL_FILLRECTANGLE)//DFXL_NONE DFXL_FILLRECTANGLE
 
-#define VMWARE_SUPPORTED_DRAWINGFUNCTIONS  (DFXL_FILLRECTANGLE)
-
-#define VMWARE_SUPPORTED_BLITTINGFLAGS     (DSBLIT_NOFX)
-
-#define VMWARE_SUPPORTED_BLITTINGFUNCTIONS (DFXL_BLIT)
+#define VMWARE_SUPPORTED_BLITTINGFLAGS     (DSBLIT_SRC_COLORKEY|DSBLIT_DST_COLORKEY|DSBLIT_BLEND_ALPHACHANNEL|DSBLIT_BLEND_COLORALPHA|DSBLIT_ROTATE90|DSBLIT_ROTATE180|DSBLIT_ROTATE270|DSBLIT_FLIP_HORIZONTAL|DSBLIT_FLIP_VERTICAL)//DSBLIT_NOFX
 
+#define VMWARE_SUPPORTED_BLITTINGFUNCTIONS (DFXL_BLIT|DFXL_STRETCHBLIT)//DFXL_NONE DFXL_BLIT|DFXL_STRETCHBLIT
 
 DFBResult vmwareEngineSync   ( void                *drv,
                                void                *dev );
@@ -63,5 +61,9 @@
                                int                  dx,
                                int                  dy );
 
-#endif
+bool      vmwareStretchBlit  ( void                *drv,
+                               void                *dev,
+                               DFBRectangle        *srect,
+                               DFBRectangle        *drect );
 
+#endif
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_gfxdriver.c DirectFB-1.4.11/gfxdrivers/vmware/vmware_gfxdriver.c
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_gfxdriver.c	2010-10-31 16:49:49.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/vmware_gfxdriver.c	2011-06-11 11:45:47.130342000 +0800
@@ -28,12 +28,24 @@
 #include <direct/messages.h>
 
 #include <core/gfxcard.h>
+#include <fcntl.h>
+#include <linux/fb.h>//jshwang
+#include <sys/mman.h>//jshwang
 
 #include "vmware_2d.h"
 #include "vmware_gfxdriver.h"
 
 
 #include <core/graphics_driver.h>
+#include <core/surface_pool.h>
+
+int   hmp =0;
+extern unsigned int   mpmem[100];
+extern unsigned int fbdata[3];
+CoreSurfacePool *vmware_pool;
+
+extern SurfacePoolFuncs vmwareSurfacePoolFuncs;
+
 
 DFB_GRAPHICS_DRIVER( vmware )
 
@@ -47,8 +59,8 @@
           case FB_ACCEL_VMWARE_BLITTER:
                return 1;
      }
-
-     return 0;
+        
+     return 1;//jshwang
 }
 
 static void
@@ -86,6 +98,11 @@
      funcs->SetState      = vmwareSetState;
      funcs->FillRectangle = vmwareFillRectangle;
      funcs->Blit          = vmwareBlit;
+	 funcs->StretchBlit   = vmwareStretchBlit;
+	 
+	 dfb_surface_pool_initialize( core, &vmwareSurfacePoolFuncs, &vmware_pool );   
+//	 dfb_surface_pool_join( core, vmware_pool, &vmwareSurfacePoolFuncs );
+	 
 
      return DFB_OK;
 }
@@ -96,7 +113,12 @@
                     void               *driver_data,
                     void               *device_data )
 {
-     /* fill device info */
+    
+    int fbfd, fbsize;
+    struct fb_var_screeninfo vinfo;
+    unsigned char *fbbuf;
+ 
+    /* fill device info */
      snprintf( device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH, "VMWare" );
      snprintf( device_info->name,   DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,   "(fake) Blitter" );
 
@@ -108,9 +130,16 @@
      device_info->caps.accel    = VMWARE_SUPPORTED_DRAWINGFUNCTIONS |
                                   VMWARE_SUPPORTED_BLITTINGFUNCTIONS;
      device_info->caps.drawing  = VMWARE_SUPPORTED_DRAWINGFLAGS;
-     device_info->caps.blitting = VMWARE_SUPPORTED_BLITTINGFLAGS;
-
-     return DFB_OK;
+     device_info->caps.blitting = VMWARE_SUPPORTED_BLITTINGFLAGS;  
+	
+   //open g2d
+     if((hmp = open("/dev/g2d",O_RDWR)) == -1)
+     {
+     	 printf("[jshwang][%d][%s][%s]open g2d dev failed!\n", __LINE__, __FILE__,__FUNCTION__);
+         return DFB_FAILURE;
+     }
+	 
+    return DFB_OK;
 }
 
 static void
@@ -118,6 +147,11 @@
                      void               *driver_data,
                      void               *device_data )
 {
+	if(hmp != NULL)
+	{
+    	close(hmp); //close the g2d driver
+		hmp =0;
+	}
 }
 
 static void
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_gfxdriver.h DirectFB-1.4.11/gfxdrivers/vmware/vmware_gfxdriver.h
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_gfxdriver.h	2010-10-31 16:49:49.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/vmware_gfxdriver.h	2011-06-11 19:54:07.840661000 +0800
@@ -33,19 +33,32 @@
      int                    v_flags;
 
      /* cached/computed values */
-     void                  *dst_addr;
-     unsigned long          dst_pitch;
-     DFBSurfacePixelFormat  dst_format;
-     unsigned long          dst_bpp;
-
-     void                  *src_addr;
-     unsigned long          src_pitch;
-     DFBSurfacePixelFormat  src_format;
-     unsigned long          src_bpp;
+     void                    *dst_addr;
+	 void                    *dst_paddr;
+     unsigned long            dst_pitch;
+     DFBSurfacePixelFormat    dst_format;
+     unsigned long            dst_bpp;
+
+     void                    *src_addr;
+	 void                    *src_paddr;
+     unsigned long            src_pitch;
+     DFBSurfacePixelFormat    src_format;
+     unsigned long            src_bpp;
 
-     unsigned long          color_pixel;
+     unsigned long            color_pixel;
 
      /** Add shared data here... **/
+     u32                      src_colorkey;
+	 u32                      alpha;
+     DFBSurfaceDrawingFlags   drawingflags; 
+     DFBSurfaceBlittingFlags  blittingflags;
+	 u32                      src_width;
+	 u32                      src_height;
+	 u32                      dst_width;
+	 u32                      dst_height;
+     
+//     int hmp;//mp handle
+     
 } VMWareDeviceData;
 
 
diff -uN DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_surface_pool.c DirectFB-1.4.11/gfxdrivers/vmware/vmware_surface_pool.c
--- DirectFB-1.4.11_ori/gfxdrivers/vmware/vmware_surface_pool.c	1970-01-01 08:00:00.000000000 +0800
+++ DirectFB-1.4.11/gfxdrivers/vmware/vmware_surface_pool.c	2011-06-11 11:44:06.038897000 +0800
@@ -0,0 +1,365 @@
+/*
+   (c) Copyright 2001-2009  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrj盲l盲 <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <direct/debug.h>
+#include <direct/mem.h>
+
+#include <fusion/fusion.h>
+
+#include <core/core.h>
+#include <core/surface_pool.h>
+
+#include <sys/mman.h> //jshwang
+#include <fcntl.h> //jshwang
+#include <sys/ioctl.h>
+
+#include "drv_display_sun4i.h"
+#include "g2d_driver.h"
+
+extern int hmp;
+unsigned int pmpmem[100];
+unsigned int fbdata[3];
+unsigned int mpmem_size[100];
+
+
+/**********************************************************************************************************************/
+
+typedef struct {
+} LocalPoolData;
+
+typedef struct {
+     FusionCall  call;
+} LocalPoolLocalData;
+
+typedef struct {
+     int         magic;
+
+     void       *addr;
+     int         pitch;
+     int         size;
+
+     FusionCall  call;
+     FusionID    fid;
+} LocalAllocationData;
+
+static int get_phyaddr(unsigned int vaddr);
+
+static FusionCallHandlerResult
+vmware_surface_pool_call_handler( int           caller,
+                                 int           call_arg,
+                                 void         *call_ptr,
+                                 void         *ctx,
+                                 unsigned int  serial,
+                                 int          *ret_val )
+{
+	int i;
+	unsigned long arg[2];
+
+	if(hmp)
+	{
+		for(i=0;i<100;i++)
+		{
+			if(call_ptr==pmpmem[i])//get index
+			{
+				break;
+			}
+		}
+
+		arg[0] = i;	
+		arg[1] = 0;
+		if(ioctl(hmp,G2D_CMD_MEM_RELEASE,(void*)arg) < 0)//release mpmem			
+		{				
+			return FCHR_RETURN;//use this return correct??			 
+		} 
+		munmap(pmpmem[i], mpmem_size[i]);
+		pmpmem[i] = 0;
+		mpmem_size[i]=0;
+	}
+	else
+	{
+		D_FREE( call_ptr );
+	} 
+
+	*ret_val = 0;
+
+	return FCHR_RETURN;
+
+}
+
+/**********************************************************************************************************************/
+
+static int
+vmwarePoolDataSize( void )
+{
+     return sizeof(LocalPoolData);
+}
+
+static int
+vmwarePoolLocalDataSize( void )
+{
+     return sizeof(LocalPoolLocalData);
+}
+
+static int
+vmwareAllocationDataSize( void )
+{
+     return sizeof(LocalAllocationData);
+}
+
+static DFBResult
+vmwareInitPool( CoreDFB                    *core,
+               CoreSurfacePool            *pool,
+               void                       *pool_data,
+               void                       *pool_local,
+               void                       *system_data,
+               CoreSurfacePoolDescription *ret_desc )
+{
+   LocalPoolLocalData *local = pool_local;
+
+    D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_ASSERT( pool_local != NULL );
+     D_ASSERT( ret_desc != NULL );
+
+     ret_desc->caps              = CSPCAPS_NONE;
+     ret_desc->access[CSAID_CPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->access[CSAID_GPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->types             = CSTF_FONT | CSTF_INTERNAL;
+     ret_desc->priority          = CSPP_PREFERED;
+     snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "System Memory" );
+
+     fusion_call_init( &local->call, vmware_surface_pool_call_handler, local, dfb_core_world(core) );  
+	 
+     return DFB_OK;
+}
+
+
+static DFBResult
+vmwareDestroyPool( CoreSurfacePool *pool,
+                  void            *pool_data,
+                  void            *pool_local )
+{
+     CoreSurfaceAllocation *allocation;
+     LocalPoolLocalData    *local = pool_local;
+     LocalAllocationData   *data;
+     FusionID               fid;
+
+     DFBResult res;
+     int       i;
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_ASSERT( pool_local != NULL );
+
+     res = fusion_call_destroy( &local->call );
+     fid = fusion_id( dfb_core_world(NULL) );
+
+     /* remove the local allocations */
+     fusion_vector_foreach (allocation, i, pool->allocs) {
+          data = allocation->data;
+          if( data->fid == fid )
+               D_FREE( data->addr );
+     }
+
+     return res;    
+}
+
+
+static DFBResult
+vmwareAllocateBuffer( CoreSurfacePool       *pool,
+                     void                  *pool_data,
+                     void                  *pool_local,
+                     CoreSurfaceBuffer     *buffer,
+                     CoreSurfaceAllocation *allocation,
+                     void                  *alloc_data )
+{
+    int i;
+    unsigned long arg[2];
+    int index;
+    
+     CoreSurface         *surface;
+     LocalPoolLocalData  *local = pool_local;
+     LocalAllocationData *alloc = alloc_data;
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_ASSERT( alloc != NULL );
+
+     surface = buffer->surface;
+     D_MAGIC_ASSERT( surface, CoreSurface );
+
+     dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size );
+
+     if (hmp)//check
+     {
+            arg[0] = alloc->size;
+            arg[1] = 0;
+            index = ioctl(hmp,G2D_CMD_MEM_REQUEST,(void*)arg);//get index		 	
+            if(index < 0)			
+            {               
+                return DFB_FAILURE;           
+            }
+            else
+            {
+                if(!pmpmem[index])//check index no used before
+                {
+                    arg[0] = index;	
+                    arg[1] = 0;
+                    if(ioctl(hmp,G2D_CMD_MEM_SELIDX,(void*)arg) < 0)
+                    {               
+                        printf("MP_CMD_MEM_SELIDX failed!\n");
+                        return DFB_FAILURE;           
+                    }           
+                    pmpmem[index] = mmap(NULL, alloc->size, PROT_READ | PROT_WRITE, MAP_SHARED, hmp, 0);//get virtual addr                            
+                    mpmem_size[index]=alloc->size;
+                    alloc->addr = pmpmem[index];//get addr
+                }
+                else
+                {
+                    printf("get mpmem index error!\n");             
+                    return DFB_FAILURE;           
+                }
+            }
+     }
+     else
+     {
+        alloc->addr = D_MALLOC( alloc->size );
+        if (!alloc->addr)
+             return D_OOM();
+     }    
+
+     alloc->call = local->call;
+     alloc->fid  = fusion_id( dfb_core_world(NULL) );
+
+     D_MAGIC_SET( alloc, LocalAllocationData );
+
+     allocation->flags = CSALF_VOLATILE;
+     allocation->size  = alloc->size;
+
+     return DFB_OK;
+
+}
+
+static DFBResult
+vmwareDeallocateBuffer( CoreSurfacePool       *pool,
+                       void                  *pool_data,
+                       void                  *pool_local,
+                       CoreSurfaceBuffer     *buffer,
+                       CoreSurfaceAllocation *allocation,
+                       void                  *alloc_data )
+{
+     DFBResult            ret;
+     LocalAllocationData *alloc = alloc_data;
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_MAGIC_ASSERT( alloc, LocalAllocationData );
+
+     ret = fusion_call_execute( &alloc->call, FCEF_ONEWAY, 0, alloc->addr, NULL );
+
+     D_MAGIC_CLEAR( alloc );
+
+     return DFB_OK;
+}
+
+static DFBResult
+vmwareLock( CoreSurfacePool  *pool,
+           void                  *pool_data,
+           void                  *pool_local,
+           CoreSurfaceAllocation *allocation,
+           void                  *alloc_data,
+           CoreSurfaceBufferLock *lock )
+{
+     LocalAllocationData *alloc = alloc_data;
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
+     D_MAGIC_ASSERT( alloc, LocalAllocationData );
+
+     lock->addr  = alloc->addr;
+	 lock->phys  = get_phyaddr(alloc->addr);
+     lock->pitch = alloc->pitch;
+
+     return DFB_OK;
+}
+
+static DFBResult
+vmwareUnlock( CoreSurfacePool       *pool,
+             void                  *pool_data,
+             void                  *pool_local,
+             CoreSurfaceAllocation *allocation,
+             void                  *alloc_data,
+             CoreSurfaceBufferLock *lock )
+{
+     LocalAllocationData *alloc = alloc_data;
+
+     D_MAGIC_ASSERT( pool, CoreSurfacePool );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
+     D_MAGIC_ASSERT( alloc, LocalAllocationData );
+
+     return DFB_OK;
+}
+
+const SurfacePoolFuncs vmwareSurfacePoolFuncs = {
+     .PoolDataSize       = vmwarePoolDataSize,
+     .PoolLocalDataSize  = vmwarePoolLocalDataSize,
+     .AllocationDataSize = vmwareAllocationDataSize,
+
+     .InitPool           = vmwareInitPool,
+     .DestroyPool        = vmwareDestroyPool,
+     .AllocateBuffer     = vmwareAllocateBuffer,
+     .DeallocateBuffer   = vmwareDeallocateBuffer,
+     .Lock               = vmwareLock,
+     .Unlock             = vmwareUnlock,
+};
+
+static int get_phyaddr(unsigned int vaddr)
+{
+	int i;
+
+	int phy = 0;
+	int arg[2];
+	
+	if(hmp)
+	{
+		for(i=0;i<100;i++)
+		{
+			if(vaddr==pmpmem[i])
+				break;
+		}
+		arg[0] = i;
+		arg[1] = 0;
+		
+		phy = ioctl(hmp,G2D_CMD_MEM_GETADR,(void*)arg);
+	}
+
+	return phy;
+
+}
